{"version":3,"file":"panelStack.js","sourceRoot":"","sources":["../../../../src/components/panel-stack/panelStack.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport { AbstractPureComponent2, Classes } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { IProps } from \"../../common/props\";\nimport { IPanel } from \"./panelProps\";\nimport { PanelView } from \"./panelView\";\n\n/* eslint-disable deprecation/deprecation */\n\nexport interface IPanelStackProps extends IProps {\n    /**\n     * The initial panel to show on mount. This panel cannot be removed from the\n     * stack and will appear when the stack is empty.\n     * This prop is only used in uncontrolled mode and is thus mutually\n     * exclusive with the `stack` prop.\n     */\n    initialPanel?: IPanel<any>;\n\n    /**\n     * Callback invoked when the user presses the back button or a panel invokes\n     * the `closePanel()` injected prop method.\n     */\n    onClose?: (removedPanel: IPanel) => void;\n\n    /**\n     * Callback invoked when a panel invokes the `openPanel(panel)` injected\n     * prop method.\n     */\n    onOpen?: (addedPanel: IPanel) => void;\n\n    /**\n     * If false, PanelStack will render all panels in the stack to the DOM, allowing their\n     * React component trees to maintain state as a user navigates through the stack.\n     * Panels other than the currently active one will be invisible.\n     *\n     * @default true\n     */\n    renderActivePanelOnly?: boolean;\n\n    /**\n     * Whether to show the header with the \"back\" button in each panel.\n     *\n     * @default true\n     */\n    showPanelHeader?: boolean;\n\n    /**\n     * The full stack of panels in controlled mode. The last panel in the stack\n     * will be displayed.\n     */\n    stack?: Array<IPanel<any>>;\n}\n\nexport interface IPanelStackState {\n    /** Whether the stack is currently animating the push or pop of a panel. */\n    direction: \"push\" | \"pop\";\n\n    /** The current stack of panels. The first panel in the stack will be displayed. */\n    stack: IPanel[];\n}\n\n/**\n * Panel stack component.\n *\n * @see https://blueprintjs.com/docs/#core/components/panel-stack\n * @deprecated use `PanelStack2<T>`\n */\n\nexport class PanelStack extends AbstractPureComponent2<IPanelStackProps, IPanelStackState> {\n    public state: IPanelStackState = {\n        direction: \"push\",\n        stack:\n            this.props.stack != null\n                ? this.props.stack.slice().reverse()\n                : this.props.initialPanel !== undefined\n                ? [this.props.initialPanel]\n                : [],\n    };\n\n    public componentDidUpdate(prevProps: IPanelStackProps, prevState: IPanelStackState) {\n        super.componentDidUpdate(prevProps, prevState);\n\n        // Always update local stack if stack prop changes\n        if (this.props.stack !== prevProps.stack && prevProps.stack != null) {\n            this.setState({ stack: this.props.stack!.slice().reverse() });\n        }\n\n        // Only update animation direction if stack length changes\n        const stackLength = this.props.stack != null ? this.props.stack.length : 0;\n        const prevStackLength = prevProps.stack != null ? prevProps.stack.length : 0;\n        if (stackLength !== prevStackLength && prevProps.stack != null) {\n            this.setState({\n                direction: prevProps.stack.length - this.props.stack!.length < 0 ? \"push\" : \"pop\",\n            });\n        }\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.PANEL_STACK,\n            `${Classes.PANEL_STACK}-${this.state.direction}`,\n            this.props.className,\n        );\n        return (\n            <TransitionGroup className={classes} component=\"div\">\n                {this.renderPanels()}\n            </TransitionGroup>\n        );\n    }\n\n    protected validateProps(props: IPanelStackProps) {\n        if (\n            (props.initialPanel == null && props.stack == null) ||\n            (props.initialPanel != null && props.stack != null)\n        ) {\n            console.error(Errors.PANEL_STACK_INITIAL_PANEL_STACK_MUTEX);\n        }\n        if (props.stack != null && props.stack.length === 0) {\n            console.error(Errors.PANEL_STACK_REQUIRES_PANEL);\n        }\n    }\n\n    private renderPanels() {\n        const { renderActivePanelOnly = true } = this.props;\n        const { stack } = this.state;\n        if (stack.length === 0) {\n            return null;\n        }\n        const panelsToRender = renderActivePanelOnly ? [stack[0]] : stack;\n        const panelViews = panelsToRender.map(this.renderPanel).reverse();\n        return panelViews;\n    }\n\n    private renderPanel = (panel: IPanel, index: number) => {\n        const { renderActivePanelOnly, showPanelHeader = true } = this.props;\n        const { stack } = this.state;\n\n        // With renderActivePanelOnly={false} we would keep all the CSSTransitions rendered,\n        // therefore they would not trigger the \"enter\" transition event as they were entered.\n        // To force the enter event, we want to change the key, but stack.length is not enough\n        // and a single panel should not rerender as long as it's hidden.\n        // This key contains two parts: first one, stack.length - index is constant (and unique) for each panel,\n        // second one, active changes only when the panel becomes or stops being active.\n        const layer = stack.length - index;\n        const key = renderActivePanelOnly ? stack.length : layer;\n\n        return (\n            <CSSTransition classNames={Classes.PANEL_STACK} key={key} timeout={400}>\n                <PanelView\n                    onClose={this.handlePanelClose}\n                    onOpen={this.handlePanelOpen}\n                    panel={panel}\n                    previousPanel={stack[index + 1]}\n                    showHeader={showPanelHeader}\n                />\n            </CSSTransition>\n        );\n    };\n\n    private handlePanelClose = (panel: IPanel) => {\n        const { stack } = this.state;\n        // only remove this panel if it is at the top and not the only one.\n        if (stack[0] !== panel || stack.length <= 1) {\n            return;\n        }\n        this.props.onClose?.(panel);\n        if (this.props.stack == null) {\n            this.setState(state => ({\n                direction: \"pop\",\n                stack: state.stack.slice(1),\n            }));\n        }\n    };\n\n    private handlePanelOpen = (panel: IPanel) => {\n        this.props.onOpen?.(panel);\n        if (this.props.stack == null) {\n            this.setState(state => ({\n                direction: \"push\",\n                stack: [panel, ...state.stack],\n            }));\n        }\n    };\n}\n"]}