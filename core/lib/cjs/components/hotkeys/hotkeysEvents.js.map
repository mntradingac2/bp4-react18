{"version":3,"file":"hotkeysEvents.js","sourceRoot":"","sources":["../../../../src/components/hotkeys/hotkeysEvents.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Children, ReactNode } from \"react\";\n\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey, IHotkeyProps } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nimport { IHotkeysProps } from \"./hotkeysTypes\";\n\nconst SHOW_DIALOG_KEY = \"?\";\n\nexport enum HotkeyScope {\n    LOCAL = \"local\",\n    GLOBAL = \"global\",\n}\n\nexport interface IHotkeyAction {\n    combo: IKeyCombo;\n    props: IHotkeyProps;\n}\n\nexport class HotkeysEvents {\n    private actions = [] as IHotkeyAction[];\n\n    public constructor(private scope: HotkeyScope) {}\n\n    public count() {\n        return this.actions.length;\n    }\n\n    public clear() {\n        this.actions = [];\n    }\n\n    public setHotkeys(props: IHotkeysProps & { children?: ReactNode }) {\n        const actions = [] as IHotkeyAction[];\n        Children.forEach(props.children, (child: ReactNode) => {\n            if (isElementOfType(child, Hotkey) && this.isScope(child.props)) {\n                actions.push({\n                    combo: parseKeyCombo(child.props.combo),\n                    props: child.props,\n                });\n            }\n        });\n        this.actions = actions;\n    }\n\n    public handleKeyDown = (e: KeyboardEvent) => {\n        const combo = getKeyCombo(e);\n        const isTextInput = this.isTextInput(e);\n\n        if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n            if (isHotkeysDialogShowing()) {\n                hideHotkeysDialogAfterDelay();\n            } else {\n                showHotkeysDialog(this.actions.map(action => action.props));\n            }\n            return;\n        } else if (isHotkeysDialogShowing()) {\n            return;\n        }\n\n        this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    public handleKeyUp = (e: KeyboardEvent) => {\n        if (isHotkeysDialogShowing()) {\n            return;\n        }\n        this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n\n    private invokeNamedCallbackIfComboRecognized(\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) {\n        const isTextInput = this.isTextInput(e);\n        for (const action of this.actions) {\n            const shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;\n            if (!shouldIgnore && comboMatches(action.combo, combo)) {\n                if (action.props.preventDefault) {\n                    e.preventDefault();\n                }\n                if (action.props.stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                action.props[callbackName]?.(e);\n            }\n        }\n    }\n\n    private isScope(props: IHotkeyProps) {\n        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n    }\n\n    private isTextInput(e: KeyboardEvent) {\n        const elem = e.target as HTMLElement;\n        // we check these cases for unit testing, but this should not happen\n        // during normal operation\n        if (elem == null || elem.closest == null) {\n            return false;\n        }\n\n        const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n        if (editable == null) {\n            return false;\n        }\n\n        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n        if (editable.tagName.toLowerCase() === \"input\") {\n            const inputType = (editable as HTMLInputElement).type;\n            if (inputType === \"checkbox\" || inputType === \"radio\") {\n                return false;\n            }\n        }\n\n        // don't let read-only fields prevent hotkey behavior\n        if ((editable as HTMLInputElement).readOnly) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"]}