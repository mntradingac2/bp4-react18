{"version":3,"file":"multiSlider.js","sourceRoot":"","sources":["../../../../src/components/slider/multiSlider.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleProps, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nconst MultiSliderHandle: React.FC<HandleProps> = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n\nexport interface ISliderBaseProps extends Props, IntentProps {\n    children?: React.ReactNode;\n\n    /**\n     * Whether the slider is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Increment between successive labels. Must be greater than zero.\n     *\n     * @default inferred (if labelStepSize is undefined)\n     */\n    labelStepSize?: number;\n\n    /**\n     * Array of specific values for the label placement. This prop is mutually exclusive with\n     * `labelStepSize`.\n     */\n    labelValues?: readonly number[];\n\n    /**\n     * Number of decimal places to use when rendering label value. Default value is the number of\n     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom\n     * `labelRenderer` callback.\n     *\n     * @default inferred from stepSize\n     */\n    labelPrecision?: number;\n\n    /**\n     * Maximum value of the slider. Value must be a finite number.\n     *\n     * @default 10\n     */\n    max?: number;\n\n    /**\n     * Minimum value of the slider. Value must be a finite number.\n     *\n     * @default 0\n     */\n    min?: number;\n\n    /**\n     * Whether a solid bar should be rendered on the track between current and initial values,\n     * or between handles for `RangeSlider`.\n     *\n     * @default true\n     */\n    showTrackFill?: boolean;\n\n    /**\n     * Increment between successive values; amount by which the handle moves. Must be greater than zero.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * Callback to render a single label. Useful for formatting numbers as currency or percentages.\n     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.\n     * If `false`, labels will not be shown.\n     *\n     * The callback is provided a numeric value and optional rendering options, which include:\n     * - isHandleTooltip: whether this label is being rendered within a handle tooltip\n     *\n     * @default true\n     */\n    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | JSX.Element);\n\n    /**\n     * Whether to show the slider in a vertical orientation.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type MultiSliderProps = IMultiSliderProps;\n/** @deprecated use MultiSliderProps */\nexport interface IMultiSliderProps extends ISliderBaseProps {\n    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */\n    defaultTrackIntent?: Intent;\n\n    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */\n    onChange?(values: number[]): void;\n\n    /** Callback invoked when a handle is released. Receives handle values in sorted order. */\n    onRelease?(values: number[]): void;\n}\n\nexport interface ISliderState {\n    labelPrecision: number;\n    /** the client size, in pixels, of one tick */\n    tickSize: number;\n    /** the size of one tick as a ratio of the component's client size */\n    tickSizeRatio: number;\n}\n\n/**\n * Multi slider component.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.multi-slider\n */\nexport class MultiSlider extends AbstractPureComponent2<MultiSliderProps, ISliderState> {\n    public static defaultSliderProps: ISliderBaseProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n\n    public static defaultProps: MultiSliderProps = {\n        ...MultiSlider.defaultSliderProps,\n        defaultTrackIntent: Intent.NONE,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n\n    public static Handle = MultiSliderHandle;\n\n    public static getDerivedStateFromProps(props: MultiSliderProps) {\n        return { labelPrecision: MultiSlider.getLabelPrecision(props) };\n    }\n\n    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;\n    }\n\n    public state: ISliderState = {\n        labelPrecision: getLabelPrecision(this.props),\n        tickSize: 0,\n        tickSizeRatio: 0,\n    };\n\n    private handleElements: Handle[] = [];\n\n    private trackElement: HTMLElement | null = null;\n\n    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {\n        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        const newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.SLIDER,\n            {\n                [Classes.DISABLED]: this.props.disabled,\n                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n                [Classes.VERTICAL]: this.props.vertical,\n            },\n            this.props.className,\n        );\n        return (\n            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>\n                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>\n                    {this.renderTracks()}\n                </div>\n                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>\n                {this.renderHandles()}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateTickSize();\n    }\n\n    public componentDidUpdate(prevProps: MultiSliderProps, prevState: ISliderState) {\n        super.componentDidUpdate(prevProps, prevState);\n        this.updateTickSize();\n    }\n\n    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {\n        if (props.stepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n        if (props.min !== undefined && !isFinite(props.min)) {\n            throw new Error(Errors.SLIDER_MIN);\n        }\n        if (props.max !== undefined && !isFinite(props.max)) {\n            throw new Error(Errors.SLIDER_MAX);\n        }\n\n        let anyInvalidChildren = false;\n        React.Children.forEach(props.children, child => {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    }\n\n    private formatLabel(value: number, isHandleTooltip: boolean = false) {\n        const { labelRenderer } = this.props;\n        if (labelRenderer === false) {\n            return undefined;\n        } else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip });\n        } else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    }\n\n    private renderLabels() {\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n\n        const values = this.getLabelValues();\n        const { max, min } = this.props;\n        const labels = values.map((step, i) => {\n            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));\n            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (\n                <div className={Classes.SLIDER_LABEL} key={i} style={style}>\n                    {this.formatLabel(step)}\n                </div>\n            );\n        });\n\n        return labels;\n    }\n\n    private renderTracks() {\n        const trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max! });\n\n        // render from current to previous, then increment previous\n        let previous: HandleProps = { value: this.props.min! };\n        const handles: JSX.Element[] = [];\n        for (let index = 0; index < trackStops.length; index++) {\n            const current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    }\n\n    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {\n        // ensure startRatio <= endRatio\n        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(\n            (left, right) => left - right,\n        );\n        const startOffset = formatPercentage(startRatio);\n        const endOffset = formatPercentage(1 - endRatio);\n        const orientationStyle: React.CSSProperties = this.props.vertical\n            ? { bottom: startOffset, top: endOffset, left: 0 }\n            : { left: startOffset, right: endOffset, top: 0 };\n\n        const style: React.CSSProperties = {\n            ...orientationStyle,\n            ...(start.trackStyleAfter || end.trackStyleBefore || {}),\n        };\n\n        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return <div key={`track-${index}`} className={classes} style={style} />;\n    }\n\n    private renderHandles() {\n        const { disabled, max, min, stepSize, vertical } = this.props;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        if (handleProps.length === 0) {\n            return null;\n        }\n\n        return handleProps.map(({ value, type, className, htmlProps }, index) => (\n            <Handle\n                htmlProps={htmlProps}\n                className={classNames(\n                    {\n                        [Classes.START]: type === HandleType.START,\n                        [Classes.END]: type === HandleType.END,\n                    },\n                    className,\n                )}\n                disabled={disabled}\n                key={`${index}-${handleProps.length}`}\n                label={this.formatLabel(value, true)}\n                max={max!}\n                min={min!}\n                onChange={this.getHandlerForIndex(index, this.handleChange)}\n                onRelease={this.getHandlerForIndex(index, this.handleRelease)}\n                ref={this.addHandleRef}\n                stepSize={stepSize!}\n                tickSize={this.state.tickSize}\n                tickSizeRatio={this.state.tickSizeRatio}\n                value={value}\n                vertical={vertical!}\n            />\n        ));\n    }\n\n    private addHandleRef = (ref: Handle) => {\n        if (ref != null) {\n            this.handleElements.push(ref);\n        }\n    };\n\n    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.mouseEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleMovement(event);\n            }\n        }\n    };\n\n    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.touchEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleTouchMovement(event);\n            }\n        }\n    };\n\n    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        const target = event.target as HTMLElement;\n        // ensure event does not come from inside the handle\n        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n\n    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {\n        return argMin(handles, handle => {\n            const offset = getOffset(handle);\n            const offsetValue = handle.clientToValue(offset);\n            const handleValue = handle.props.value!;\n            return Math.abs(offsetValue - handleValue);\n        });\n    }\n\n    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {\n        return (newValue: number) => {\n            callback?.(this.getNewHandleValues(newValue, index));\n        };\n    };\n\n    private getNewHandleValues(newValue: number, oldIndex: number) {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        const newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort((left, right) => left - right);\n\n        const newIndex = newValues.indexOf(newValue);\n        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        } else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            const lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n\n        return newValues;\n    }\n\n    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {\n        const inc = startIndex < endIndex ? 1 : -1;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n\n        return -1;\n    }\n\n    private handleChange = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        if (!Utils.arraysEqual(newValues, oldValues)) {\n            this.props.onChange?.(newValues);\n            handleProps.forEach((handle, index) => {\n                if (oldValues[index] !== newValues[index]) {\n                    handle.onChange?.(newValues[index]);\n                }\n            });\n        }\n    };\n\n    private handleRelease = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        this.props.onRelease?.(newValues);\n        handleProps.forEach((handle, index) => {\n            handle.onRelease?.(newValues[index]);\n        });\n    };\n\n    private getLabelValues() {\n        const { labelStepSize, labelValues, min, max } = this.props;\n        let values: number[] = [];\n        if (labelValues !== undefined) {\n            values = labelValues.slice();\n        } else {\n            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {\n                values.push(i);\n            }\n        }\n\n        return values;\n    }\n\n    private getOffsetRatio(value: number) {\n        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);\n    }\n\n    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        } else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent!;\n    }\n\n    private updateTickSize() {\n        if (this.trackElement != null) {\n            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));\n            const tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize, tickSizeRatio });\n        }\n    }\n}\n\nfunction getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {\n    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\n\nfunction getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {\n    const maybeHandles = React.Children.map(children, child =>\n        Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null,\n    );\n    let handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(handle => handle !== null);\n    handles.sort((left, right) => left.value - right.value);\n    return handles;\n}\n"]}