{"version":3,"file":"asyncControllableInput.js","sourceRoot":"","sources":["../../../../src/components/forms/asyncControllableInput.tsx"],"names":[],"mappings":"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","sourcesContent":["/* !\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, DISPLAYNAME_PREFIX } from \"../../common\";\n\nexport interface IAsyncControllableInputProps\n    extends React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement> {\n    inputRef?: React.LegacyRef<HTMLInputElement>;\n}\n\ntype InputValue = IAsyncControllableInputProps[\"value\"];\n\nexport interface IAsyncControllableInputState {\n    /**\n     * Whether we are in the middle of a composition event.\n     *\n     * @default false\n     */\n    isComposing: boolean;\n\n    /**\n     * The source of truth for the input value. This is not updated during IME composition.\n     * It may be updated by a parent component.\n     *\n     * @default \"\"\n     */\n    value: InputValue;\n\n    /**\n     * The latest input value, which updates during IME composition. Defaults to props.value.\n     */\n    nextValue: InputValue;\n\n    /**\n     * Whether there is a pending update we are expecting from a parent component.\n     *\n     * @default false\n     */\n    hasPendingUpdate: boolean;\n}\n\n/**\n * A stateful wrapper around the low-level <input> component which works around a\n * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input\n * receives CompositionEvents (for example, through IME composition) and has its value prop updated\n * asychronously. This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n *\n * Note: this component does not apply any Blueprint-specific styling.\n */\nexport class AsyncControllableInput extends AbstractPureComponent2<\n    IAsyncControllableInputProps,\n    IAsyncControllableInputState\n> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.AsyncControllableInput`;\n\n    /**\n     * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n     * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n     */\n    public static COMPOSITION_END_DELAY = 10;\n\n    public state: IAsyncControllableInputState = {\n        hasPendingUpdate: false,\n        isComposing: false,\n        nextValue: this.props.value,\n        value: this.props.value,\n    };\n\n    private cancelPendingCompositionEnd: (() => void) | null = null;\n\n    public static getDerivedStateFromProps(\n        nextProps: IAsyncControllableInputProps,\n        nextState: IAsyncControllableInputState,\n    ): Partial<IAsyncControllableInputState> | null {\n        if (nextState.isComposing || nextProps.value === undefined) {\n            // don't derive anything from props if:\n            // - in uncontrolled mode, OR\n            // - currently composing, since we'll do that after composition ends\n            return null;\n        }\n\n        const userTriggeredUpdate = nextState.nextValue !== nextState.value;\n\n        if (userTriggeredUpdate) {\n            if (nextProps.value === nextState.nextValue) {\n                // parent has processed and accepted our update\n                if (nextState.hasPendingUpdate) {\n                    return { value: nextProps.value, hasPendingUpdate: false };\n                } else {\n                    return { value: nextState.nextValue };\n                }\n            } else {\n                if (nextProps.value === nextState.value) {\n                    // we have sent the update to our parent, but it has not been processed yet. just wait.\n                    // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n                    // causing the cursor to jump once the new value is accepted\n                    return { hasPendingUpdate: true };\n                }\n                // accept controlled update overriding user action\n                return { value: nextProps.value, nextValue: nextProps.value, hasPendingUpdate: false };\n            }\n        } else {\n            // accept controlled update, could be confirming or denying user action\n            return { value: nextProps.value, nextValue: nextProps.value, hasPendingUpdate: false };\n        }\n    }\n\n    public render() {\n        const { isComposing, hasPendingUpdate, value, nextValue } = this.state;\n        const { inputRef, ...restProps } = this.props;\n        return (\n            <input\n                {...restProps}\n                ref={inputRef}\n                // render the pending value even if it is not confirmed by a parent's async controlled update\n                // so that the cursor does not jump to the end of input as reported in\n                // https://github.com/palantir/blueprint/issues/4298\n                value={isComposing || hasPendingUpdate ? nextValue : value}\n                onCompositionStart={this.handleCompositionStart}\n                onCompositionEnd={this.handleCompositionEnd}\n                onChange={this.handleChange}\n            />\n        );\n    }\n\n    private handleCompositionStart = (e: React.CompositionEvent<HTMLInputElement>) => {\n        this.cancelPendingCompositionEnd?.();\n        this.setState({ isComposing: true });\n        this.props.onCompositionStart?.(e);\n    };\n\n    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {\n        // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n        // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n        // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n        // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n        // passed without a new composition event starting.\n        this.cancelPendingCompositionEnd = this.setTimeout(\n            () => this.setState({ isComposing: false }),\n            AsyncControllableInput.COMPOSITION_END_DELAY,\n        );\n        this.props.onCompositionEnd?.(e);\n    };\n\n    private handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = e.target;\n\n        this.setState({ nextValue: value });\n        this.props.onChange?.(e);\n    };\n}\n"]}