{"version":3,"file":"tagInput.js","sourceRoot":"","sources":["../../../../src/components/tag-input/tagInput.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys, refHandler, setRef, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, HTMLInputProps, IntentProps, MaybeElement, Props } from \"../../common/props\";\nimport { getActiveElement } from \"../../common/utils\";\nimport { Icon, IconName, IconSize } from \"../icon/icon\";\nimport { Tag, TagProps } from \"../tag/tag\";\nimport { ResizableInput } from \"./resizableInput\";\n\n/**\n * The method in which a `TagInput` value was added.\n * - `\"default\"` - indicates that a value was added by manual selection.\n * - `\"blur\"` - indicates that a value was added when the `TagInput` lost focus.\n *   This is only possible when `addOnBlur=true`.\n * - `\"paste\"` - indicates that a value was added via paste. This is only\n *   possible when `addOnPaste=true`.\n */\nexport type TagInputAddMethod = \"default\" | \"blur\" | \"paste\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type TagInputProps = ITagInputProps;\n/** @deprecated use TagInputProps */\nexport interface ITagInputProps extends IntentProps, Props {\n    /**\n     * If true, `onAdd` will be invoked when the input loses focus.\n     * Otherwise, `onAdd` is only invoked when `enter` is pressed.\n     *\n     * @default false\n     */\n    addOnBlur?: boolean;\n\n    /**\n     * If true, `onAdd` will be invoked when the user pastes text containing the `separator`\n     * into the input. Otherwise, pasted text will remain in the input.\n     *\n     * __Note:__ For example, if `addOnPaste=true` and `separator=\"\\n\"` (new line), then:\n     * - Pasting `\"hello\"` will _not_ invoke `onAdd`\n     * - Pasting `\"hello\\n\"` will invoke `onAdd` with `[\"hello\"]`\n     * - Pasting `\"hello\\nworld\"` will invoke `onAdd` with `[\"hello\", \"world\"]`\n     *\n     * @default true\n     */\n    addOnPaste?: boolean;\n\n    /**\n     * Whether the component should automatically resize as a user types in the text input.\n     * This will have no effect when `fill={true}`.\n     *\n     * @default false\n     */\n    autoResize?: boolean;\n\n    /**\n     * Optional child elements which will be rendered between the selected tags and\n     * the text input. Rendering children is usually unnecessary.\n     *\n     * @default undefined\n     */\n    children?: React.ReactNode;\n\n    /**\n     * Whether the component is non-interactive.\n     * Note that you'll also need to disable the component's `rightElement`,\n     * if appropriate.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the tag input should take up the full width of its container. */\n    fill?: boolean;\n\n    /**\n     * React props to pass to the `<input>` element.\n     * Note that `ref` and `key` are not supported here; use `inputRef` below.\n     * Also note that `inputProps.style.width` will be overriden if `autoResize={true}`.\n     */\n    inputProps?: HTMLInputProps;\n\n    /** Ref handler for the `<input>` element. */\n    inputRef?: React.Ref<HTMLInputElement>;\n\n    /** Controlled value of the `<input>` element. This is shorthand for `inputProps={{ value }}`. */\n    inputValue?: string;\n\n    /** Whether the tag input should use a large size. */\n    large?: boolean;\n\n    /** Name of a Blueprint UI icon (or an icon element) to render on the left side of the input. */\n    leftIcon?: IconName | MaybeElement;\n\n    /**\n     * Callback invoked when new tags are added by the user pressing `enter` on the input.\n     * Receives the current value of the input field split by `separator` into an array.\n     * New tags are expected to be appended to the list.\n     *\n     * The input will be cleared after `onAdd` is invoked _unless_ the callback explicitly\n     * returns `false`. This is useful if the provided `value` is somehow invalid and should\n     * not be added as a tag.\n     */\n    onAdd?: (values: string[], method: TagInputAddMethod) => boolean | void;\n\n    /**\n     * Callback invoked when new tags are added or removed. Receives the updated list of `values`:\n     * new tags are appended to the end of the list, removed tags are removed at their index.\n     *\n     * Like `onAdd`, the input will be cleared after this handler is invoked _unless_ the callback\n     * explicitly returns `false`.\n     *\n     * This callback essentially implements basic `onAdd` and `onRemove` functionality and merges\n     * the two handlers into one to simplify controlled usage.\n     * ```\n     */\n    onChange?: (values: React.ReactNode[]) => boolean | void;\n\n    /**\n     * Callback invoked when the value of `<input>` element is changed.\n     * This is shorthand for `inputProps={{ onChange }}`.\n     */\n    onInputChange?: React.FormEventHandler<HTMLInputElement>;\n\n    /**\n     * Callback invoked when the user depresses a keyboard key.\n     * Receives the event and the index of the active tag (or `undefined` if\n     * focused in the input).\n     */\n    onKeyDown?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;\n\n    /**\n     * Callback invoked when the user releases a keyboard key.\n     * Receives the event and the index of the active tag (or `undefined` if\n     * focused in the input).\n     */\n    onKeyUp?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;\n\n    /**\n     * Callback invoked when the user clicks the X button on a tag.\n     * Receives value and index of removed tag.\n     */\n    onRemove?: (value: React.ReactNode, index: number) => void;\n\n    /**\n     * Input placeholder text which will not appear if `values` contains any items\n     * (consistent with default HTML input behavior).\n     * Use `inputProps.placeholder` if you want the placeholder text to _always_ appear.\n     *\n     * If you define both `placeholder` and `inputProps.placeholder`, then the former will appear\n     * when `values` is empty and the latter at all other times.\n     */\n    placeholder?: string;\n\n    /**\n     * Element to render on right side of input.\n     * For best results, use a small spinner or minimal button (button height will adjust if `TagInput` uses large styles).\n     * Other elements will likely require custom styles for correct positioning.\n     */\n    rightElement?: JSX.Element;\n\n    /**\n     * Separator pattern used to split input text into multiple values. Default value splits on commas and newlines.\n     * Explicit `false` value disables splitting (note that `onAdd` will still receive an array of length 1).\n     *\n     * @default /[,\\n\\r]/\n     */\n    separator?: string | RegExp | false;\n\n    /**\n     * React props to pass to each `Tag`. Provide an object to pass the same props to every tag,\n     * or a function to customize props per tag.\n     *\n     * If you define `onRemove` here then you will have to implement your own tag removal\n     * handling as `TagInput`'s own `onRemove` handler will never be invoked.\n     */\n    tagProps?: TagProps | ((value: React.ReactNode, index: number) => TagProps);\n\n    /**\n     * Controlled tag values. Each value will be rendered inside a `Tag`, which can be customized\n     * using `tagProps`. Therefore, any valid React node can be used as a `TagInput` value; falsy\n     * values will not be rendered.\n     */\n    values: readonly React.ReactNode[];\n}\n\nexport interface ITagInputState {\n    activeIndex: number;\n    inputValue: string;\n    isInputFocused: boolean;\n    prevInputValueProp?: string;\n}\n\n/** special value for absence of active tag */\nconst NONE = -1;\n\n/**\n * Tag input component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tag-input\n */\nexport class TagInput extends AbstractPureComponent2<TagInputProps, ITagInputState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.TagInput`;\n\n    public static defaultProps: Partial<TagInputProps> = {\n        addOnBlur: false,\n        addOnPaste: true,\n        autoResize: false,\n        inputProps: {},\n        separator: /[,\\n\\r]/,\n        tagProps: {},\n    };\n\n    public static getDerivedStateFromProps(\n        props: Readonly<TagInputProps>,\n        state: Readonly<ITagInputState>,\n    ): Partial<ITagInputState> | null {\n        if (props.inputValue !== state.prevInputValueProp) {\n            return {\n                inputValue: props.inputValue,\n                prevInputValueProp: props.inputValue,\n            };\n        }\n        return null;\n    }\n\n    public state: ITagInputState = {\n        activeIndex: NONE,\n        inputValue: this.props.inputValue || \"\",\n        isInputFocused: false,\n    };\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private handleRef: React.Ref<HTMLInputElement> = refHandler(this, \"inputElement\", this.props.inputRef);\n\n    public render() {\n        const { autoResize, className, disabled, fill, inputProps, intent, large, leftIcon, placeholder, values } =\n            this.props;\n\n        const classes = classNames(\n            Classes.INPUT,\n            Classes.TAG_INPUT,\n            {\n                [Classes.ACTIVE]: this.state.isInputFocused,\n                [Classes.DISABLED]: disabled,\n                [Classes.FILL]: fill,\n                [Classes.LARGE]: large,\n            },\n            Classes.intentClass(intent),\n            className,\n        );\n        const isLarge = classes.indexOf(Classes.LARGE) > NONE;\n\n        // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n        const isSomeValueDefined = values.some(val => !!val);\n        const resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps?.placeholder : placeholder;\n\n        // final props that may be sent to <input> or <ResizableInput>\n        const resolvedInputProps = {\n            value: this.state.inputValue,\n            ...inputProps,\n            className: classNames(Classes.INPUT_GHOST, inputProps?.className),\n            disabled,\n            onChange: this.handleInputChange,\n            onFocus: this.handleInputFocus,\n            onKeyDown: this.handleInputKeyDown,\n            onKeyUp: this.handleInputKeyUp,\n            onPaste: this.handleInputPaste,\n            placeholder: resolvedPlaceholder,\n            ref: this.handleRef,\n        };\n\n        return (\n            <div className={classes} onBlur={this.handleContainerBlur} onClick={this.handleContainerClick}>\n                <Icon\n                    className={Classes.TAG_INPUT_ICON}\n                    icon={leftIcon}\n                    size={isLarge ? IconSize.LARGE : IconSize.STANDARD}\n                />\n                <div className={Classes.TAG_INPUT_VALUES}>\n                    {values.map(this.maybeRenderTag)}\n                    {this.props.children}\n                    {autoResize ? <ResizableInput {...resolvedInputProps} /> : <input {...resolvedInputProps} />}\n                </div>\n                {this.props.rightElement}\n            </div>\n        );\n    }\n\n    public componentDidUpdate(prevProps: TagInputProps) {\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.handleRef = refHandler(this, \"inputElement\", this.props.inputRef);\n            setRef(this.props.inputRef, this.inputElement);\n        }\n    }\n\n    private addTags = (value: string, method: TagInputAddMethod = \"default\") => {\n        const { inputValue, onAdd, onChange, values } = this.props;\n        const newValues = this.getValues(value);\n        let shouldClearInput = onAdd?.(newValues, method) !== false && inputValue === undefined;\n        // avoid a potentially expensive computation if this prop is omitted\n        if (Utils.isFunction(onChange)) {\n            shouldClearInput = onChange([...values, ...newValues]) !== false && shouldClearInput;\n        }\n        // only explicit return false cancels text clearing\n        if (shouldClearInput) {\n            this.setState({ inputValue: \"\" });\n        }\n    };\n\n    private maybeRenderTag = (tag: React.ReactNode, index: number) => {\n        if (!tag) {\n            return null;\n        }\n        const { large, tagProps } = this.props;\n        const props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n        return (\n            <Tag\n                active={index === this.state.activeIndex}\n                data-tag-index={index}\n                key={tag + \"__\" + index}\n                large={large}\n                onRemove={this.props.disabled ? undefined : this.handleRemoveTag}\n                {...props}\n            >\n                {tag}\n            </Tag>\n        );\n    };\n\n    private getNextActiveIndex(direction: number) {\n        const { activeIndex } = this.state;\n        if (activeIndex === NONE) {\n            // nothing active & moving left: select last defined value. otherwise select nothing.\n            return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n        } else {\n            // otherwise, move in direction and clamp to bounds.\n            // note that upper bound allows going one beyond last item\n            // so focus can move off the right end, into the text input.\n            return this.findNextIndex(activeIndex, direction);\n        }\n    }\n\n    private findNextIndex(startIndex: number, direction: number) {\n        const { values } = this.props;\n        let index = startIndex + direction;\n        while (index > 0 && index < values.length && !values[index]) {\n            index += direction;\n        }\n        return Utils.clamp(index, 0, values.length);\n    }\n\n    /**\n     * Splits inputValue on separator prop,\n     * trims whitespace from each new value,\n     * and ignores empty values.\n     */\n    private getValues(inputValue: string) {\n        const { separator } = this.props;\n        // NOTE: split() typings define two overrides for string and RegExp.\n        // this does not play well with our union prop type, so we'll just declare it as a valid type.\n        return (separator === false ? [inputValue] : inputValue.split(separator as string))\n            .map(val => val.trim())\n            .filter(val => val.length > 0);\n    }\n\n    private handleContainerClick = () => {\n        this.inputElement?.focus();\n    };\n\n    private handleContainerBlur = ({ currentTarget }: React.FocusEvent<HTMLDivElement>) => {\n        this.requestAnimationFrame(() => {\n            // we only care if the blur event is leaving the container.\n            // defer this check using rAF so activeElement will have updated.\n            const isFocusInsideContainer = currentTarget.contains(getActiveElement(this.inputElement));\n            if (!isFocusInsideContainer) {\n                if (this.props.addOnBlur && this.state.inputValue !== undefined && this.state.inputValue.length > 0) {\n                    this.addTags(this.state.inputValue, \"blur\");\n                }\n                this.setState({ activeIndex: NONE, isInputFocused: false });\n            }\n        });\n    };\n\n    private handleInputFocus = (event: React.FocusEvent<HTMLInputElement>) => {\n        this.setState({ isInputFocused: true });\n        this.props.inputProps?.onFocus?.(event);\n    };\n\n    private handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({ activeIndex: NONE, inputValue: event.currentTarget.value });\n        this.props.onInputChange?.(event);\n        this.props.inputProps?.onChange?.(event);\n    };\n\n    private handleInputKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable deprecation/deprecation */\n\n        const { selectionEnd, value } = event.currentTarget;\n        const { activeIndex } = this.state;\n\n        let activeIndexToEmit = activeIndex;\n\n        if (event.which === Keys.ENTER && value.length > 0) {\n            this.addTags(value, \"default\");\n        } else if (selectionEnd === 0 && this.props.values.length > 0) {\n            // cursor at beginning of input allows interaction with tags.\n            // use selectionEnd to verify cursor position and no text selection.\n            if (event.which === Keys.ARROW_LEFT || event.which === Keys.ARROW_RIGHT) {\n                const nextActiveIndex = this.getNextActiveIndex(event.which === Keys.ARROW_RIGHT ? 1 : -1);\n                if (nextActiveIndex !== activeIndex) {\n                    event.stopPropagation();\n                    activeIndexToEmit = nextActiveIndex;\n                    this.setState({ activeIndex: nextActiveIndex });\n                }\n            } else if (event.which === Keys.BACKSPACE) {\n                this.handleBackspaceToRemove(event);\n            } else if (event.which === Keys.DELETE) {\n                this.handleDeleteToRemove(event);\n            }\n        }\n\n        this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n    };\n\n    private handleInputKeyUp = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        this.invokeKeyPressCallback(\"onKeyUp\", event, this.state.activeIndex);\n    };\n\n    private handleInputPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {\n        const { separator } = this.props;\n        const value = event.clipboardData.getData(\"text\");\n\n        if (!this.props.addOnPaste || value.length === 0) {\n            return;\n        }\n\n        // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n        // the input field so that the user can refine it before converting it to a tag manually.\n        if (separator === false || value.split(separator!).length === 1) {\n            return;\n        }\n\n        event.preventDefault();\n        this.addTags(value, \"paste\");\n    };\n\n    private handleRemoveTag = (event: React.MouseEvent<HTMLSpanElement>) => {\n        // using data attribute to simplify callback logic -- one handler for all children\n        const index = +event.currentTarget.parentElement!.getAttribute(\"data-tag-index\")!;\n        this.removeIndexFromValues(index);\n    };\n\n    private handleBackspaceToRemove(event: React.KeyboardEvent<HTMLInputElement>) {\n        const previousActiveIndex = this.state.activeIndex;\n        // always move leftward one item (this will focus last item if nothing is focused)\n        this.setState({ activeIndex: this.getNextActiveIndex(-1) });\n        // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n        if (this.isValidIndex(previousActiveIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(previousActiveIndex);\n        }\n    }\n\n    private handleDeleteToRemove(event: React.KeyboardEvent<HTMLInputElement>) {\n        const { activeIndex } = this.state;\n        if (this.isValidIndex(activeIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(activeIndex);\n        }\n    }\n\n    /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n    private removeIndexFromValues(index: number) {\n        const { onChange, onRemove, values } = this.props;\n        onRemove?.(values[index], index);\n        onChange?.(values.filter((_, i) => i !== index));\n    }\n\n    private invokeKeyPressCallback(\n        propCallbackName: \"onKeyDown\" | \"onKeyUp\",\n        event: React.KeyboardEvent<HTMLInputElement>,\n        activeIndex: number,\n    ) {\n        this.props[propCallbackName]?.(event, activeIndex === NONE ? undefined : activeIndex);\n        this.props.inputProps![propCallbackName]?.(event);\n    }\n\n    /** Returns whether the given index represents a valid item in `this.props.values`. */\n    private isValidIndex(index: number) {\n        return index !== NONE && index < this.props.values.length;\n    }\n}\n"]}