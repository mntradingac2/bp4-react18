{"version":3,"file":"overflowList.js","sourceRoot":"","sources":["../../../../src/components/overflow-list/overflowList.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, Props } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type OverflowListProps<T> = IOverflowListProps<T>;\n/** @deprecated use OverflowListProps */\nexport interface IOverflowListProps<T> extends Props {\n    /**\n     * Whether to force the overflowRenderer to always be called, even if there are zero items\n     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover\n     * which you do not want to close as the list is resized.\n     *\n     * @default false\n     */\n    alwaysRenderOverflow?: boolean;\n\n    /**\n     * Which direction the items should collapse from: start or end of the\n     * children. This also determines whether `overflowRenderer` appears before\n     * (`START`) or after (`END`) the visible items.\n     *\n     * @default Boundary.START\n     */\n    collapseFrom?: Boundary;\n\n    /**\n     * All items to display in the list. Items that do not fit in the container\n     * will be rendered in the overflow instead.\n     */\n    items: readonly T[];\n\n    /**\n     * The minimum number of visible items that should never collapse into the\n     * overflow menu, regardless of DOM dimensions.\n     *\n     * @default 0\n     */\n    minVisibleItems?: number;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed. If changes to a parent's size is detected, the overflow will be\n     * recalculated.\n     *\n     * Only enable this prop if the overflow should be recalculated when a\n     * parent element resizes in a way that does not also cause the\n     * `OverflowList` to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * Callback invoked when the overflowed items change. This is called once\n     * after the DOM has settled, rather that on every intermediate change. It\n     * is not invoked if resizing produces an unchanged overflow state.\n     */\n    onOverflow?: (overflowItems: T[]) => void;\n\n    /**\n     * Callback invoked to render the overflowed items. Unlike\n     * `visibleItemRenderer`, this prop is invoked once with all items that do\n     * not fit in the container.\n     *\n     * Typical use cases for this prop will put overflowed items in a dropdown\n     * menu or display a \"+X items\" label.\n     */\n    overflowRenderer: (overflowItems: T[]) => React.ReactNode;\n\n    /** CSS properties to apply to the root element. */\n    style?: React.CSSProperties;\n\n    /**\n     * HTML tag name for the container element.\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n\n    /**\n     * Callback invoked to render each visible item.\n     * Remember to set a `key` on the rendered element!\n     */\n    visibleItemRenderer: (item: T, index: number) => React.ReactChild;\n}\n\nexport interface IOverflowListState<T> {\n    /** Whether repartitioning is still active. An overflow can take several frames to settle. */\n    repartitioning: boolean;\n    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */\n    lastOverflowCount: number;\n    overflow: readonly T[];\n    visible: readonly T[];\n    /** Pointer for the binary search algorithm used to find the finished non-overflowing state */\n    chopSize: number;\n    lastChopSize: number | null;\n}\n\n/**\n * Overflow list component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overflow-list\n */\nexport class OverflowList<T> extends React.Component<OverflowListProps<T>, IOverflowListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\n\n    public static defaultProps: Partial<OverflowListProps<any>> = {\n        alwaysRenderOverflow: false,\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n\n    public static ofType<U>() {\n        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;\n    }\n\n    public state: IOverflowListState<T> = {\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: false,\n        visible: this.props.items,\n    };\n\n    private spacer: HTMLElement | null = null;\n\n    public componentDidMount() {\n        this.repartition();\n    }\n\n    public shouldComponentUpdate(nextProps: OverflowListProps<T>, nextState: IOverflowListState<T>) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n        // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n        return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    }\n\n    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: IOverflowListState<T>) {\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n\n        if (\n            prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer\n        ) {\n            // reset visible state if the above props change.\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                lastOverflowCount: 0,\n                overflow: [],\n                repartitioning: true,\n                visible: this.props.items,\n            });\n        }\n\n        const { repartitioning, overflow, lastOverflowCount } = this.state;\n\n        if (\n            // if a resize operation has just completed\n            repartitioning === false &&\n            prevState.repartitioning === true\n        ) {\n            // only invoke the callback if the UI has actually changed\n            if (overflow.length !== lastOverflowCount) {\n                this.props.onOverflow?.(overflow.slice());\n            }\n        } else if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition();\n        }\n    }\n\n    public render() {\n        const { className, collapseFrom, observeParents, style, tagName = \"div\", visibleItemRenderer } = this.props;\n        const overflow = this.maybeRenderOverflow();\n        const list = React.createElement(\n            tagName,\n            {\n                className: classNames(Classes.OVERFLOW_LIST, className),\n                style,\n            },\n            collapseFrom === Boundary.START ? overflow : null,\n            this.state.visible.map(visibleItemRenderer),\n            collapseFrom === Boundary.END ? overflow : null,\n            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,\n        );\n\n        return (\n            <ResizeSensor onResize={this.resize} observeParents={observeParents}>\n                {list}\n            </ResizeSensor>\n        );\n    }\n\n    private maybeRenderOverflow() {\n        const { overflow } = this.state;\n        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow.slice());\n    }\n\n    private resize = () => {\n        this.repartition();\n    };\n\n    private repartition() {\n        if (this.spacer == null) {\n            return;\n        }\n\n        // if lastChopSize was 1, then our binary search has exhausted.\n        const partitionExhausted = this.state.lastChopSize === 1;\n        const minVisible = this.props.minVisibleItems ?? 0;\n\n        // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n        const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n\n        // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n        const shouldGrow =\n            (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) &&\n            this.state.overflow.length > 0 &&\n            !partitionExhausted;\n\n        if (shouldShrink || shouldGrow) {\n            this.setState(state => {\n                let visible;\n                let overflow;\n                if (this.props.collapseFrom === Boundary.END) {\n                    const result = shiftElements(\n                        state.visible,\n                        state.overflow,\n                        this.state.chopSize * (shouldShrink ? 1 : -1),\n                    );\n                    visible = result[0];\n                    overflow = result[1];\n                } else {\n                    const result = shiftElements(\n                        state.overflow,\n                        state.visible,\n                        this.state.chopSize * (shouldShrink ? -1 : 1),\n                    );\n                    overflow = result[0];\n                    visible = result[1];\n                }\n\n                return {\n                    chopSize: halve(state.chopSize),\n                    lastChopSize: state.chopSize,\n                    // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n                    lastOverflowCount: this.isFirstPartitionCycle(state.chopSize)\n                        ? state.overflow.length\n                        : state.lastOverflowCount,\n                    overflow,\n                    repartitioning: true,\n                    visible,\n                };\n            });\n        } else {\n            // repartition complete!\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                repartitioning: false,\n            });\n        }\n    }\n\n    private defaultChopSize(): number {\n        return halve(this.props.items.length);\n    }\n\n    private isFirstPartitionCycle(currentChopSize: number): boolean {\n        return currentChopSize === this.defaultChopSize();\n    }\n}\n\nfunction halve(num: number): number {\n    return Math.ceil(num / 2);\n}\n\nfunction shiftElements<T>(leftArray: readonly T[], rightArray: readonly T[], num: number): [newFrom: T[], newTo: T[]] {\n    // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n    const allElements = leftArray.concat(rightArray);\n    const newLeftLength = leftArray.length - num;\n\n    if (newLeftLength <= 0) {\n        return [[], allElements];\n    } else if (newLeftLength >= allElements.length) {\n        return [allElements, []];\n    }\n\n    const sliceIndex = allElements.length - newLeftLength;\n\n    return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}\n"]}